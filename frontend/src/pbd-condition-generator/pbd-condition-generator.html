<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../../bower_components/paper-button/paper-button.html">
<link rel="import" href="../../bower_components/paper-styles/color.html">
<link rel="import" href="../../bower_components/ros-topic/ros-topic.html">
<link rel="import" href="../shared-styles/shared-styles.html">

<dom-module id="pbd-condition-generator">
  <template>
    <style include="shared-styles"></style>
    <style is="custom-style" include="iron-flex iron-flex-alignment"></style>
    <style>
      :host {
        display: block;

      }
      .title {
        border-top: 1px solid var(--paper-grey-300);
        padding-top: 10px;
        margin-bottom: 10px;
      }
      .title paper-button {
        height: 30px;
      }
      paper-input {
        display: inline-block;
        max-width: 200px;
        margin-left: 10px; 
      }
      .number {
        max-width: 60px;
      }
      paper-dropdown-menu {
        max-width: 200px;
        margin-left: 10px; 
      }
      h3 {
        margin: auto 0px;
        display: inline-block;
      }
      #wrap {
        width:100%;
      }
      #left_col {
        float:left;
        width:50%;
      }
      #right_col {
        float:right;
        width:50%;
      }
    </style>
    <ros-topic auto
      id="eventPub"
      msg-type="rapid_pbd_msgs/EditorEvent"
      topic="rapid_pbd/editor_events"
      ros="[[ros]]"
    ></ros-topic>
    <div class="center horizontal layout title">
      <h3>Action [[index]]conditions</h3>
    </div>
  </template>
  <script>
    Polymer({
      is: 'pbd-check-conditions-action',
      properties: {
        index: String, //Pre/Post
        landmarks: {
          type: Array,
          value: function() { return []; }
        },
        spatial_relations: {
          type: Array,
          value: function() { return []; }
        },
        params: Object,
        program: Object,
        programId: String,
        ros: Object,
        conditions: Array,
        currentCondition: Object,
        conditionIndex: Number,
        landmark: Object,
        reference: Object,
        position: Object,
        orientation: Object,
        
      },

      observers: [
        // '_computeLandmarks(program, index)',
        // '_computeSpatialRelations(program)',
        //  '_computeCondition(index, conditionIndex)',
      ],

      _computeCondition(index, conditionIndex) {

         if (!conditionIndex || conditionIndex < 0) {
          conditionIndex = 0;
        } 
         console.debug('_computeCondition: ', conditionIndex);
         if (this.conditions) {
          console.debug('current condition', this.currentCondition);
          this.currentCondition = this.conditions[conditionIndex];
         }
          //
        // }
        // if (this.index === 'Pre') {
        //    this.currentCondition = this.conditions[conditionIndex];
        //  console.debug('_computeCondition: for ', this.currentCondition);

        //  }
        // else if (this.index === 'Post') {
        //    this.currentCondition = program.steps[program.steps.length-1].conditions[conditionIndex];
         //console.debug('_computeCondition: for currentCondition:', this.currentCondition.landmark.name);
        
        
        //updateConditionValues(this.currentCondition);
      },

      // _computeLandmarks(program, index) {
      //   console.debug('_computeLandmarks: ', index);
      //   var surfaceLandmarks = [];
      //   if (program ) {
      //     // Search backward for surface landmarks
      //     for (var i=program.steps.length-1; i>=0; --i) {
      //       var stepLandmarks = program.steps[i].landmarks;
      //       var stepSurfaceLandmarks = [];
      //       for (var li=0; li<stepLandmarks.length; ++li) {
      //         var landmark = stepLandmarks[li];
      //         if (landmark.type === 'surface box') {
      //           stepSurfaceLandmarks.push(landmark);
      //         }
      //       }
      //       if (stepSurfaceLandmarks.length > 0) {
      //         surfaceLandmarks = stepSurfaceLandmarks;
      //         break;
      //       }
      //     }
      //   }

      //   var landmarks = [
      //     {
      //       type: 'none',
      //       name: 'none'
      //     }
      //   ];
      //   landmarks = landmarks.concat(surfaceLandmarks);
      //   this.set('landmarks', landmarks);

      //   console.debug('_computeLandmarks: landmarks found:', landmarks.length);

      // },

      // hasConditions: function(program) {

      //   console.debug('hasConditions: ', this.index);
      //   if (this._isPre) {
      //     return this.getPrecondition(program).length > 0;
      //   }
      //   else if (this._isPost) {
      //     return this.getPostcondition(program).length > 0;
      //   }
      //   else {
      //     console.debug('hasConditions: Invalid condition', this.index);
      //   }
      // },

      // isNull: function(reference) {
      //     return reference.name.length() > 0;
      // },

      // _addAction: function(evt) {
      //   var action = evt.detail;
      //   var msg = {
      //     type: 'add action',
      //     program_info: {
      //       db_id: this.programId
      //     },
      //     step_num: this.index,
      //     action: action

      //   };
      //   this.$.eventPub.publish(msg);

      //   this.$.picker.opened = false;
      // },

      // _stepNum: function(index) {
      //   return (index);
      // },

      // _togglePicker: function() {
      //   this.$.picker.toggle();
      // },

      // openActionPicker: function() {
      //   this.$.picker.opened = true;
      // },
      // _getConditions:function(program) {
      //   if ( this.index == "Pre" ){
      //     this._getPrecondition(program);

      //   }
      //   else if ( this.index == "Post" ){ 
      //     this._getPostcondition(program);
      //   }
      //   else {
      //     console.error('Unknown condition ', this.index);
      //   }
      // },

      // _getPrecondition: function(program) {
      //   console.debug('_getPreconditions: ', program.steps);
      //   return program.steps[0].conditions;
      // },
      // _getPostcondition: function(program) {
      //   return program.steps[program.steps.length-1].conditions;
      // },
      // _getRelationConditions: function(conditions) {
      //   var relationConditions = [];
      //   for (var i = conditions.length - 1; i >= 0; i--) {
      //     console.debug('_getRelationConditions: ', conditions[i].type);
      //     relationConditions.push(conditions[i]);
      //   }
      //     console.debug('_getRelationConditions: ', relationConditions.length);
      //     return relationConditions;
      // },

      // _relationName: function(spatial_relation) {
      //   // console.debug('_relationName: ', spatial_relation);
      //   if (spatial_relation === 'is_right_of') {
      //     return 'is right of';
      //   } if (spatial_relation === 'is_left_of') {
      //     return 'is left of';
      //   } if (spatial_relation === 'is_behind_of') {
      //     return 'is behind of';
      //   } if (spatial_relation === 'is_in_front_of') {
      //     return 'is in front of';
      //   } 
      //   return ' not relevant to ';
      // },

      _landmarkName: function(landmark) {
        if (!landmark || !landmark.type) {
          return 'Unknown landmark';
        }
        if (landmark.type === 'tf frame') {
          if (landmark.name === 'base_link' || landmark.name === 'base_footprint') {
            return 'Robot base';
          } else if (landmark.name === 'torso_lift_link') {
            return 'Robot torso';
          } else {
            return landmark.name;
          }
        } else if (landmark.type === 'surface box') {
          return landmark.name;
        } else if (landmark.type === 'none') {
          return 'None';
        }

        return 'Unknown landmark';
      },

      _computeSpatialRelations: function(action) {
        var spatial_relations = [
          'is_left_of', 'is_right_of', 'is_in_front_of', 'is_behind_of',
          'none'];
        //landmarks = landmarks.concat(surfaceLandmarks);
        this.set('spatial_relations', spatial_relations);
        console.debug('_computeSpatialRelations: ', spatial_relations.length);
        //return spatial_relations;
      },
      // _isPre: function (){
      //   return this.index === 'Pre';
      // },
      // _isPost: function (){
      //   return this.index === 'Post';
      // },

      // _updatePose: function() {

      //   var msg = {
      //     type: 'get pose',
      //     program_info: {
      //       db_id: this.programId
      //     },
      //     step_num: this.stepIndex,
      //     action_num: this.index,
      //     action: this.action

      //   };
      //   this.$.eventPub.publish(msg);
      // },
      _updateLandmark: function(evt) {
        this.set('landmark', evt.model.item);
        // If selected Main landmark is None, no condition is assigned
        this.set('conditionIndex', evt.model.index);
        console.debug('_updateLandmark: conditionIndex', this.conditionIndex);
        // if landmark selected and not 'None'
        if ( this.conditionIndex > 0 ){
          this.currentCondition = this.conditions[this.conditionIndex-1];
        } else {
          this.currentCondition = {};
        }
        // Update program's pre/postcondition
        if ( this.index === "Pre" ) {
          if ( this.conditionIndex > 0 ){
            this.program.preconditions = [this.currentCondition];
           } else {
            this.program.preconditions = [];
           }
        console.debug('_updateLandmark: program precondition is now', this.program.preconditions);
        
        } else if ( this._isPost ) {
          if ( this.conditionIndex > 0 ){
            this.program.postconditions = [this.currentCondition];
          } else {
            this.program.postconditions = [];
          }
        console.debug('_updateLandmark: program postcondition is now', this.program.postconditions);
         }
         else {

        console.debug('_updateLandmark: unknown condition selected');
         }
        //this._updatePose();
      },

      _updateReference: function(evt) {
        this.set('reference', evt.model.item);
        this.currentCondition.reference = evt.model.item;
        this._updatePose();
      },

      _updateSpatialRelation: function(evt) {
        this.set('spatial_relation', evt.model.item);
        this.currentCondition.spatial_relation = evt.model.item;
        this._updatePose();
      },
      _getDistance: function(dispmnt) {
        var x = parseFloat(dispmnt.position.x);
        var y = parseFloat(dispmnt.position.y);
        var squared_dist = x*x + y*y;
        
        console.debug('_getDistance: ', Math.sqrt(squared_dist));
        return Math.sqrt(squared_dist);
      },

      _positionRelevantChanged: function(evt) {
          this.currentCondition.positionRelevant = evt.target.checked;
          console.debug("_positionRelevantChanged: ", evt.target.checked);
      },
      _orientationRelevantChanged: function(evt) {
          this.currentCondition.orientationRelevant = evt.target.checked;
          console.debug("_orientationRelevantChanged: ", evt.target.checked);
      },
      _sizeRelevantChanged: function(evt) {
          this.currentCondition.sizeRelevant = evt.target.checked;
          console.debug("_sizeRelevantChanged: ", evt.target.checked);
      },

      // _positionThresholdChanged: function(evt) {
      //   this.currentCondition.positionThreshold = parseFloat(evt.target.value);
      //   console.debug('_positionThresholdChanged: ', this.currentCondition.positionThreshold);
      // },
      // _orientationThresholdChanged: function(evt) {
      //   this.currentCondition.orientationThreshold = parseFloat(evt.target.value);
      //   console.debug('_orientationThresholdChanged: ', this.currentCondition.orientationThreshold);
      // },
      // _sizeThresholdChanged: function(evt) {
      //   this.currentCondition.sizeThreshold = parseFloat(evt.target.value);
      //   console.debug('_sizeThresholdChanged: ', this.currentCondition.sizeThreshold);
      // },

      _distanceChanged: function(evt) {
       // this._parseInt(evt.target.value, 'condition.)
      },
      _formatDec: function(decimal) {
        return decimal.toFixed(2);
      },
      _parseString: function(s, key) {
        if (typeof s === 'string') {
          var f = parseFloat(s);
          if (!isNaN(f) && s !== '0.') {
            this.set(key, f);
          }
        } else {
          this.set(key, s);
        }
      },
      closeActionPicker: function() {
        this.$.picker.opened = false;
      }
    });
  </script>
</dom-module>
